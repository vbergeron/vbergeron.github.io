<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Field Maps | vbergeron.github.io</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction Let&rsquo;s talk about a kind of common issue in programing. Imagine you have a large form to fill, or a SQL table to select column from, or really any type of data where you are interested by selecting subsets of its atomic components (like form results, or SQL columns). I call this data structures field maps data, and let&rsquo;s see how we can implement the using the power of the Scala 3 language.">
<meta name="author" content="Valentin Bergeron">
<link rel="canonical" href="https://vbergeron.github.io/posts/0001-fieldmaps/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://vbergeron.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://vbergeron.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://vbergeron.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://vbergeron.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://vbergeron.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Field Maps" />
<meta property="og:description" content="Introduction Let&rsquo;s talk about a kind of common issue in programing. Imagine you have a large form to fill, or a SQL table to select column from, or really any type of data where you are interested by selecting subsets of its atomic components (like form results, or SQL columns). I call this data structures field maps data, and let&rsquo;s see how we can implement the using the power of the Scala 3 language." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://vbergeron.github.io/posts/0001-fieldmaps/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T14:48:55+02:00" />
<meta property="article:modified_time" content="2023-04-21T14:48:55+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Field Maps"/>
<meta name="twitter:description" content="Introduction Let&rsquo;s talk about a kind of common issue in programing. Imagine you have a large form to fill, or a SQL table to select column from, or really any type of data where you are interested by selecting subsets of its atomic components (like form results, or SQL columns). I call this data structures field maps data, and let&rsquo;s see how we can implement the using the power of the Scala 3 language."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://vbergeron.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Field Maps",
      "item": "https://vbergeron.github.io/posts/0001-fieldmaps/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Field Maps",
  "name": "Field Maps",
  "description": "Introduction Let\u0026rsquo;s talk about a kind of common issue in programing. Imagine you have a large form to fill, or a SQL table to select column from, or really any type of data where you are interested by selecting subsets of its atomic components (like form results, or SQL columns). I call this data structures field maps data, and let\u0026rsquo;s see how we can implement the using the power of the Scala 3 language.",
  "keywords": [
    
  ],
  "articleBody": "Introduction Let’s talk about a kind of common issue in programing. Imagine you have a large form to fill, or a SQL table to select column from, or really any type of data where you are interested by selecting subsets of its atomic components (like form results, or SQL columns). I call this data structures field maps data, and let’s see how we can implement the using the power of the Scala 3 language.\nThe goal is to be able to quickly represent any subset of the fields without having to create dedidated data structures each time.\nA First solution Our goal is to design such a structure in a way that prevent any runtime exception. Here are our needs :\nThe structure must be immutable : no modification in place Getting the data given a key Adding new fields to the FieldMap Since the structure will be heterogeneous, the key has to carry in some way the type of the value to return. Given these constraints, we can write it like this :\nclass Key[A] That’s it. Since this is a regular class and not a case class, each new instance will have its own identity and will carry the type information. Then, using the universal apply method, we can create keys just like this :\nval name = Key[String] val city = Key[String] val flag = Key[Boolean] To represent the FieldMap proper, given the interface specified, one can write :\ntrait FieldMap: def get[A](key: Key[A]): Option[A] def put[A](key: Key[A], data: A): FieldMap Here we are kind of forced to have an Option[A] returned in order to tackle the case of a key not present yet in the structure. We also want to emphasize immutability, so our write operations needs to return a modified copy of it.\nNow that we have a solid interface, let’s implement it ! First of all, what would be the ideal data structure to back it ? An immutable Map is a natural choice, but what would be the types of the keys and value then ?\nThe key type should be the identity of the Key[A] instance The value, well, can really be anything, so we have to resort to use Any final case class Impl(data: Map[Key[?], Any]) extends FieldMap: def get[A](key: Key[A]): Option[A] = data.get(key).map(_.asinstanceOf[A]) def put[A](key: Key[A], data: A): FieldMap = data + (key -\u003e data) This is pretty straightforward knowing that in scala everything is a subtype of Any. Casting the value on retrieval is completely safe since we already know the type thanks to the key type parameter.\nWe can then test it :\nval data = Impl(Map.empty).put(name, \"Peter\").put(flag, false) val success = data.get(name) // Some(\"Peter\") val failure = data.get(city) // None Great success ! But there are still a lot of points of improvement :\nGetting data means having to take into account the case of the key not being present. This will contaminate a lot of code with Option whereas we statically know when a key should be present or not in most of the cases.\nThere is no separation between reading and writing the fieldmap. Ideally, we should be able to give a read permit on all or part of the fields to “client” function. Power corrupts and our design should take this into consideration\nLet’s try to address these points.\nRefining the design Encoding key sets First, let’s try to address the issue around the Option return type. To safely remove this, we have to track what keys are already in the FieldMap and find a way to have a compile time error when there isn’t one. This is a good application of making invalid state unrepresentable.\nTo properly implement the type-level keyset, we need to attach it somehow to the structure. I choose to represent it as a generic parameter, but an encoding using a type member should be possible (alas more verbose).\ntrait FieldMap[Keys] To represent the set, we can use scala 3 union types, combined with singleton types. Indeed, whenever we create a key, we create a type ! Let’s look at this expression :\nval city = Key[String] What is the type of city ? One could say Key[String] and be right, but the underlying type assigned by the scala compiler is… city.type, which is a very specialized subtype of the Key[T] class.\nThen we use the property of union types, which are the least common supertype of their members, to build the set. Let’s see how everything mix together in the new interface definition.\nHere is the put method:\ndef put[A](key: Key[A], data: A): FieldMap[Keys | key.type] As we have seen before, we modify the definition to track the keys by adding the singleton type to the union.\nThe retrieval is trickier :\ndef get[A, K \u003c: Key[A] \u0026 Keys](key: K): A Let’s break it down :\nThe Option is gone : as we are going to make it impossible to retrieve a key not present, we can simplify the retrun type.\nInstead of having a Key[A] as a parameter, we use a type K that needs to satisfy two conditions: It obviously need to be a subtype of Key[A] and it needs to be a part of the key set.\nSince the set is encoded as k0.type | k1.type | … | kn.type (given k0, k1, …, kn keys), any subset would satisfy the condition. That’s why we use a intersection type to further constraint K to be a single key instance.\nThe implementation won’t change a lot, the signatures aside.\nfinal class Impl[Keys](private val m: Map[Key[?], Any]) extends FieldMap[Keys]: def get[A, K \u003c: Key[A] \u0026 Keys](key: K): A = m(key).asInstanceOf[A] def put[A](key: Key[A], data: A): FieldMap[Keys | key.type] = Impl(m + (key -\u003e data)) We can then verify how it works :\nval name = Key[String] val city = Key[String] val flag = Key[Boolean] val empty: FieldMap[Nothing] = Impl(Map.empty) val data: FieldMap[name.type | city.type] = empty.put(name, \"Peter\").put(flag, false) val success = data.get(name) // \"Peter\" val failure = data.get(city) // compile error ! The compile error is pretty clear also:\nFound: (city : Key[String]) Required: Key[A] \u0026 ((name : Key[String]) | (flag : Key[Boolean])) We reached ou goal, the FieldMap is now typesafe for the get operation !\nReader/Writer separation A pretty nice feature would be to restrict as much as possible the set of capabilities the main structure can delegate to functions and users.\nFirst we can eat the low hanging fruit and clearly separate the reader from the rest using trait composition:\ntrait FieldMapReader[Keys]: def get[A, K \u003c: Keys \u0026 Key[A]](key: K): A trait FieldMap[Keys] extends FieldMapReader[Keys]: def put[A](key: Key[A], data: A): FieldMap[Keys | key.type] This way, we can ask for a FieldMapReader[Keys] instead of the power of the full blown map. As our structure was immutable from the start, it was also less dangerous to pass around but this ensures another layer of safety (and it costs pretty much nothing !).\nLet’s take it further. We can add contravariance to the Keys parameter, and using the fact that A | Bis a subtype of A | B | C, function can now specify exactly the keys they need in their signature, further locking the structure.\nIn order to relax the assumption, we can always bring back the Option based get method that won’t have a strong requirement on the keyset.\n// The new interface, using contravariance trait FieldMapReader[-Keys]: def get[A, K \u003c: Keys \u0026 Key[A]](key: K): A def opt[A](key: Key[A]): Option[A] trait FieldMap[-Keys] extends FieldMapReader[Keys]: def put[A](key: Key[A], data: A): FieldMap[Keys | key.type] def withNameAndFlag(data: FieldMapReader[name.type | flag.type]) = // here we can only safely get the name and flag, gated by the type system val maybeCity = data.opt(city) // still usable but can be empty s\"Doing something with ${data.get(name)} or ${data.get(flag)}\" val data = data.put(name, \"foobared\").put(flag, true) withNameAndFlag(data) // compiles and typecheck the needed fields val onlyCity = data.put(city, \"Paris\") withNameAndFlag(onlyCity) // does not compile since the required fields are not set Conclusion In this post, we detailed the implementation of a field map, which is a data structure that can accept typed keys and modelize sets of type-dependant key-values. Scala, and especially the union types and intersection types, helps us a lot achieving this goal.\nStill, there is a lot we can to to improve it !\nThe fine grained accesses that enable this implementation could be used to fuel the initialization of complex, modularized apps. A dependency can be viewed as a FieldMapReader[Deps] =\u003e Service ofr instance, and the layers could be combined with a state monad (maybe in a next post in this series !). The backing structure is known at compile time, thus could be implemented more efficiently using scala 3 tuples. I hope you enjoyed the read, and see you soon !\n",
  "wordCount" : "1462",
  "inLanguage": "en",
  "datePublished": "2023-04-21T14:48:55+02:00",
  "dateModified": "2023-04-21T14:48:55+02:00",
  "author":{
    "@type": "Person",
    "name": "Valentin Bergeron"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://vbergeron.github.io/posts/0001-fieldmaps/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "vbergeron.github.io",
    "logo": {
      "@type": "ImageObject",
      "url": "https://vbergeron.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://vbergeron.github.io/" accesskey="h" title="vbergeron.github.io (Alt + H)">vbergeron.github.io</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Field Maps
    </h1>
    <div class="post-meta"><span title='2023-04-21 14:48:55 +0200 CEST'>April 21, 2023</span>&nbsp;·&nbsp;Valentin Bergeron

</div>
  </header> 
  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Let&rsquo;s talk about a kind of common issue in programing. Imagine you have a large form to fill, or a SQL table to select column from, or really any type of data where you are interested by selecting subsets of its atomic components (like form results, or SQL columns). I call this data structures <em>field maps</em> data, and let&rsquo;s see how we can implement the using the power of the Scala 3 language.</p>
<p>The goal is to be able to quickly represent any subset of the fields without having to create dedidated data structures each time.</p>
<h1 id="a-first-solution">A First solution<a hidden class="anchor" aria-hidden="true" href="#a-first-solution">#</a></h1>
<p>Our goal is to design such a structure in a way that prevent any runtime exception. Here are our needs :</p>
<ul>
<li>The structure must be immutable : no modification in place</li>
<li>Getting the data given a key</li>
<li>Adding new fields to the FieldMap</li>
</ul>
<p>Since the structure will be heterogeneous, the key has to carry in some way the type of the value to return. Given these constraints, we can write it like this :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>That’s it. Since this is a regular class and not a case class, each new instance will have its own identity and will carry the type information. Then, using the <a href="https://docs.scala-lang.org/scala3/reference/other-new-features/creator-applications.html">universal apply method</a>, we can create keys just like this :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> name <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> city <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> flag <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Boolean</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>To represent the FieldMap proper, given the interface specified, one can write :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">FieldMap</span><span style="color:#66d9ef">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#66d9ef">get</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">])</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Option</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> put<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span>
</span></span></code></pre></div><p>Here we are kind of forced to have an <code>Option[A]</code> returned in order to tackle the case of a key not present yet in the structure. We also want to emphasize immutability, so our write operations needs to return a modified copy of it.</p>
<p>Now that we have a solid interface, let’s implement it ! First of all, what would be the ideal data structure to back it ? An immutable Map is a natural choice, but what would be the types of the keys and value then ?</p>
<ul>
<li>The key type should be the identity of the Key[A] instance</li>
<li>The value, well, can really be anything, so we have to resort to use Any</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Impl</span><span style="color:#f92672">(</span>data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Map</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">?</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">Any</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">FieldMap</span><span style="color:#66d9ef">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#66d9ef">get</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">])</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Option</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span>
</span></span><span style="display:flex;"><span>    data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>key<span style="color:#f92672">).</span>map<span style="color:#f92672">(</span><span style="color:#66d9ef">_</span><span style="color:#f92672">.</span>asinstanceOf<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">])</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> put<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">-&gt;</span> data<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>This is pretty straightforward knowing that in scala everything is a subtype of Any. Casting the value on retrieval is completely safe since we already know the type thanks to the key type parameter.</p>
<p>We can then test it :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> data <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Impl</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Map</span><span style="color:#f92672">.</span>empty<span style="color:#f92672">).</span>put<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Peter&#34;</span><span style="color:#f92672">).</span>put<span style="color:#f92672">(</span>flag<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> success <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#75715e">// Some(&#34;Peter&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> failure <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>city<span style="color:#f92672">)</span> <span style="color:#75715e">// None
</span></span></span></code></pre></div><p>Great success ! But there are still a lot of points of improvement :</p>
<ul>
<li>
<p>Getting data means having to take into account the case of the key not being present. This will contaminate a lot of code with Option whereas we statically know when a key should be present or not in most of the cases.</p>
</li>
<li>
<p>There is no separation between reading and writing the fieldmap. Ideally, we should be able to give a read permit on all or part of the fields to “client” function. <em>Power corrupts</em> and our design should take this into consideration</p>
</li>
</ul>
<p>Let’s try to address these points.</p>
<h1 id="refining-the-design">Refining the design<a hidden class="anchor" aria-hidden="true" href="#refining-the-design">#</a></h1>
<h2 id="encoding-key-sets">Encoding key sets<a hidden class="anchor" aria-hidden="true" href="#encoding-key-sets">#</a></h2>
<p>First, let’s try to address the issue around the <code>Option</code> return type. To safely remove this, we have to track what keys are already in the FieldMap and find a way to have a compile time error when there isn’t one. This is a good application of making invalid state unrepresentable.</p>
<p>To properly implement the type-level keyset, we need to attach it somehow to the structure. I choose to represent it as a generic parameter, but an encoding using a type member should be possible (alas more verbose).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>To represent the set, we can use scala 3 union types, combined with singleton types. Indeed, whenever we create a key, we create a type ! Let’s look at this expression :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> city <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>What is the type of city ? One could say <code>Key[String]</code> and be right, but the underlying type assigned by the scala compiler is… <code>city.type</code>, which is a <em>very</em> specialized subtype of the <code>Key[T]</code> class.</p>
<p>Then we use the property of union types, which are the <em>least common supertype</em> of their members, to build the set. Let’s see how everything mix together in the new interface definition.</p>
<p>Here is the <code>put</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> put<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span> <span style="color:#66d9ef">|</span> <span style="color:#66d9ef">key.</span><span style="color:#66d9ef">type</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>As we have seen before, we modify the definition to track the keys by adding the singleton type to the union.</p>
<p>The retrieval is trickier :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> get<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span>, <span style="color:#66d9ef">K</span> <span style="color:#66d9ef">&lt;:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">&amp;</span> <span style="color:#66d9ef">Keys</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">K</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> 
</span></span></code></pre></div><p>Let’s break it down :</p>
<ul>
<li>
<p>The <code>Option</code> is gone :  as we are going to make it impossible to retrieve a key not present, we can simplify the retrun type.</p>
</li>
<li>
<p>Instead of having a <code>Key[A]</code> as a parameter, we use a type K that needs to satisfy two conditions: It obviously need to be a subtype of <code>Key[A]</code> and it needs to be a part of the key set.</p>
</li>
</ul>
<p>Since the set is encoded as <code>k0.type | k1.type | … | kn.type</code> (given <code>k0</code>, <code>k1</code>, &hellip;, <code>kn</code> keys), any subset would satisfy the condition. That’s why we use a <em>intersection type</em> to further constraint K to be a single key instance.</p>
<p>The implementation won’t change a lot, the signatures aside.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Impl</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">](</span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> m<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Map</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">?</span><span style="color:#f92672">]</span>, <span style="color:#66d9ef">Any</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">]</span><span style="color:#66d9ef">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#66d9ef">get</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span>, <span style="color:#66d9ef">K</span> <span style="color:#66d9ef">&lt;:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">&amp;</span> <span style="color:#66d9ef">Keys</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">K</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    m<span style="color:#f92672">(</span>key<span style="color:#f92672">).</span>asInstanceOf<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> put<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span> <span style="color:#66d9ef">|</span> <span style="color:#66d9ef">key.</span><span style="color:#66d9ef">type</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Impl</span><span style="color:#f92672">(</span>m <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">-&gt;</span> data<span style="color:#f92672">))</span>
</span></span></code></pre></div><p>We can then verify how it works :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> name <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> city <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">String</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> flag <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Boolean</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> empty<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Nothing</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span> <span style="color:#a6e22e">Impl</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Map</span><span style="color:#f92672">.</span>empty<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">name.</span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">|</span> <span style="color:#66d9ef">city.</span><span style="color:#66d9ef">type</span><span style="color:#f92672">]</span> <span style="color:#66d9ef">=</span> 
</span></span><span style="display:flex;"><span>  empty<span style="color:#f92672">.</span>put<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Peter&#34;</span><span style="color:#f92672">).</span>put<span style="color:#f92672">(</span>flag<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> success <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#75715e">// &#34;Peter&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> failure <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>city<span style="color:#f92672">)</span> <span style="color:#75715e">// compile error !
</span></span></span></code></pre></div><p>The compile error is pretty clear also:</p>
<pre tabindex="0"><code class="language-raw" data-lang="raw">Found:    (city : Key[String])
Required: Key[A] &amp; ((name : Key[String]) | (flag : Key[Boolean]))
</code></pre><p>We reached ou goal, the <code>FieldMap</code> is now typesafe for the get operation !</p>
<h2 id="readerwriter-separation">Reader/Writer separation<a hidden class="anchor" aria-hidden="true" href="#readerwriter-separation">#</a></h2>
<p>A pretty nice feature would be to restrict as much as possible the set of capabilities the main structure can delegate to functions and users.</p>
<p>First we can eat the low hanging fruit and clearly separate the reader from the rest using trait composition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">FieldMapReader</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">]</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> get<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span>, <span style="color:#66d9ef">K</span> <span style="color:#66d9ef">&lt;:</span> <span style="color:#66d9ef">Keys</span> <span style="color:#66d9ef">&amp;</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">K</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">]</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">FieldMapReader</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">]</span><span style="color:#66d9ef">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#66d9ef">put</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span> <span style="color:#66d9ef">|</span> <span style="color:#66d9ef">key.</span><span style="color:#66d9ef">type</span><span style="color:#f92672">]</span>
</span></span></code></pre></div><p>This way, we can ask for a <code>FieldMapReader[Keys]</code> instead of the power of the full blown map. As our structure was immutable from the start, it was also less dangerous to pass around but this ensures another layer of safety (and it costs pretty much nothing !).</p>
<p>Let&rsquo;s take it further. We can add contravariance to the <code>Keys</code> parameter, and using the fact that <code>A | B</code>is a subtype of <code>A | B | C</code>, function can now specify exactly the keys they need in their signature, further locking the structure.</p>
<p>In order to relax the assumption, we can always bring back the <code>Option</code> based get method that won&rsquo;t have a strong requirement on the keyset.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#75715e">// The new interface, using contravariance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">FieldMapReader</span><span style="color:#f92672">[</span><span style="color:#66d9ef">-Keys</span><span style="color:#f92672">]</span><span style="color:#a6e22e">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> get<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span>, <span style="color:#66d9ef">K</span> <span style="color:#66d9ef">&lt;:</span> <span style="color:#66d9ef">Keys</span> <span style="color:#66d9ef">&amp;</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">K</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> opt<span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">])</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Option</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">-Keys</span><span style="color:#f92672">]</span> <span style="color:#a6e22e">extends</span> <span style="color:#a6e22e">FieldMapReader</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span><span style="color:#f92672">]</span><span style="color:#66d9ef">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#66d9ef">put</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">](</span>key<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Key</span><span style="color:#f92672">[</span><span style="color:#66d9ef">A</span><span style="color:#f92672">],</span> data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">A</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMap</span><span style="color:#f92672">[</span><span style="color:#66d9ef">Keys</span> <span style="color:#66d9ef">|</span> <span style="color:#66d9ef">key.</span><span style="color:#66d9ef">type</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> withNameAndFlag<span style="color:#f92672">(</span>data<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">FieldMapReader</span><span style="color:#f92672">[</span><span style="color:#66d9ef">name.</span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">|</span> <span style="color:#66d9ef">flag.</span><span style="color:#66d9ef">type</span><span style="color:#f92672">])</span> <span style="color:#66d9ef">=</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// here we can only safely get the name and flag, gated by the type system
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">val</span> maybeCity <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>opt<span style="color:#f92672">(</span>city<span style="color:#f92672">)</span> <span style="color:#75715e">// still usable but can be empty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#e6db74">s&#34;Doing something with </span><span style="color:#e6db74">${</span>data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>name<span style="color:#f92672">)</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> or </span><span style="color:#e6db74">${</span>data<span style="color:#f92672">.</span>get<span style="color:#f92672">(</span>flag<span style="color:#f92672">)</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">val</span> data <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>put<span style="color:#f92672">(</span>name<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;foobared&#34;</span><span style="color:#f92672">).</span>put<span style="color:#f92672">(</span>flag<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>withNameAndFlag<span style="color:#f92672">(</span>data<span style="color:#f92672">)</span> <span style="color:#75715e">// compiles and typecheck the needed fields
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">val</span> onlyCity <span style="color:#66d9ef">=</span> data<span style="color:#f92672">.</span>put<span style="color:#f92672">(</span>city<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Paris&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>withNameAndFlag<span style="color:#f92672">(</span>onlyCity<span style="color:#f92672">)</span> <span style="color:#75715e">// does not compile since the required fields are not set
</span></span></span></code></pre></div><h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>In this post, we detailed the implementation of a <em>field map</em>, which is a data structure that can accept typed keys and modelize sets of type-dependant key-values. Scala, and especially the <em>union types</em> and <em>intersection types</em>, helps us a lot achieving this goal.</p>
<p>Still, there is a lot we can to to improve it !</p>
<ul>
<li>The fine grained accesses that enable this implementation could be used to fuel the initialization of complex, modularized apps. A dependency can be viewed as a <code>FieldMapReader[Deps] =&gt; Service</code> ofr instance, and the layers could be combined with a state monad (maybe in a next post in this series !).</li>
<li>The backing structure is known at compile time, thus could be implemented more efficiently using scala 3 tuples.</li>
</ul>
<p>I hope you enjoyed the read, and see you soon !</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://vbergeron.github.io/">vbergeron.github.io</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
